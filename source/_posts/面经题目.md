---
title: 面经题目
date: 2024-03-12 17:03:05
tags:
typora-root-url: ..
categories:
    - 找工作
---

# **C++**

### 1.  C++中智能指针和指针的区别是什么(腾讯:1)

智能指针会自动管理内存，可以自动释放。普通的指针需要手动管理内存，释放。智能指针实际上是对普通指针加了一层封装机制，智能指针就是一个类。

在C++11中出现三种智能指针，分别是unique_ptr、shared_ptr、weak_ptr。这三种智能指针分别有各自的应用场景，**同时这些应用场景是有相互联系的**。https://blog.csdn.net/zsiming/article/details/125783890

-  unique_ptr的出现，在一定程度上解决了裸指针使用完没有及时释放导致的内存泄漏问题，但多个unique_ptr不能指向同一资源
-  shared_ptr的出现，解决了unique_ptr不能指向同一资源的问题。它的特点是引用计数不为0，就坚决不释放资源。这又导致了另一个问题：交叉引用导致资源无法释放，又会内存泄漏
- weak_ptr的特点是引用对象时引用计数不增加，但自能成为资源的观察者，无法使用资源。如果要使用资源，必须升级为shared_ptr。weak_ptr解决了shared_ptr交叉引用的问题。

### 2.   述 C++ 中智能指针的特点，简述 new 与 malloc 的区别

智能指针可以自动管理资源，包括share,unique和weak。在函数结束的时候会自动释放内存

new是C++中的操作符，malloc是函数。

new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数。

new相当于有两个步骤：分配内存(和malloc一样)；触发构造函数。

malloc在使用的时候需要显式填入申请内存的大小

new的返回值是对象类型的指针。而malloc返回的是void*,需要再一步进行强制类型转化。

### 3. 简述C++右值引用与转移语义

左值表达式表示的是对象的身份，右值表达式表达的是对象的值。

左值对应变量的存储位置，右值对应变量的值本身

有地址的变量就是左值，没有底质的字面值、临时值就是右值

![image-20240312171608374](./images/面经题目/image-20240312171608374.png)

引用就是给变量取一个别名，和原来的变量公用一块空间。一个变量可以有多个引用，改变引用的值就改变了变量的值

左值引用要求右边的值必须能够取出地址

左值的声明符号为”&”， 为了和左值区分，右值的声明符号为”&&”。

转移语句可以将资源(堆，系统对象等)从一个对象转移到另一个对象

右值引用实现了转移语义和精确传递，能够消除两个对象相互交互时不必要的对象拷贝，节省运算存储资源，提高运行效率。

![image-20240312171639634](./images/面经题目/image-20240312171639634.png)



### 4. 只定义析构函数，会自动生成哪些构造函数

与构造函数相反，析构函数是在对象被撤销的时自动调用。

默认生成的析构函数只能释放类的普通数据成员所占用的空间, 无法释放通过 new 或 malloc 进行申请的空间。

只定义析构函数，会生成默认构造函数和拷贝构造函数。

默认构造函数是给对象赋予初始值的函数

拷贝构造函数有编辑器调用来完成一些基于同一类的其他对象的构建及初始化

![image-20240312172005215](./images/面经题目/image-20240312172005215.png)

![image-20240312232954820](./images/面经题目/image-20240312232954820.png)

### 5. C++中多态是如何实现的

通过虚函数实现动态多态，通过函数重载(参数和返回值不一样)实现静态多态

多态：一个接口有多个形态

### 6.C++中虚函数表和虚函数表指针的创建时机

虚函数在继承的过程中可以重写基类的虚函数。

在运行时才知道子类调用的哪一个函数

虚函数表的创建时机：在编译器编译的时候生成，virtual关键字修饰的函数

虚函数表是虚函数地址的数组，每有一个虚函数，数组长度就＋1.在可执行程序中存放在只读数据段，在内存中存放在代码区。

虚函数表指针(在堆区)指向虚函数表的地址，虚函数地址又指向代码段中的函数的位置。

每个类对应一个虚函数表。类不同对象的虚函数表指针指向该类的虚函数表，但每个对象的虚函数表指针不同。

### 7. 虚拟内存的构成

内核空间

栈区

文件映射区

堆取

数据区(已初始化和未初始化的数据，静态存储区)

代码区

### 8. 构造函数的底层原理

先创建一个新对象，然后构造函数里的this替换成刚刚new的对象，通过强制转换的方式对新对象添加属性和方法

### 9. 引用和指针的区别(腾讯:1)

**指针**是一个变量，它保存了另一个变量的内存地址；**引用**是另一个变量的别名，与原变量共享内存地址。

 指针可以被重新赋值，指向不同的变量；引用在初始化后不能更改，始终指向同一个变量。

 指针可以为nullptr，表示不指向任何变量；引用必须绑定到一个变量，不能为nullptr。

### 10. qt里面有用到多线程吗

为什么在QT中要使用线程？

如果我们在写GUI程序的时候，如果某处的数据，计算比较复杂，当前主线程就会卡在这里，在具体表现就是界面会卡住。所以在这个时候多线程就起到了关键的作用， 我们将复杂的逻辑运算交给线程，由线程在后台处理。<u>（注意：线程不能操作图形界面，他的线程任务是在后台进行数据运算等）</u>

![image-20240313171845511](./images/面经题目/image-20240313171845511.png)

### 11. 面向对象的特点，三大特征(腾讯:1)

继承、多态、封装

其中，**封装**可以隐藏实现细节，使得代码模块化。

**继承**可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。

而**多态**则是为了实现另一个目的——接口重用！

<img src="/images/面经题目/image-20240314110741745.png" alt="image-20240314110741745" style="zoom:67%;" />

### 12. 常用的容器有哪些，底层原理是怎么样的(腾讯:1)

1. **array** :  **顺序容器**（支持随机访问），连续内存空间，固定大小；
2. **vector**：顺序容器（支持随机访问），动态调整大小，使用内存分配器动态管理内存；是能够动态调整大小的 array
3. **deque**：顺序容器（支持随机访问），动态调整大小，使用内存分配器动态管理内存；是一个可以在首尾两端进行动态增删的顺序容器。也是动态array
4. **list**：顺序容器（可顺序访问，但不支持随机访问），双链表，使用内存分配器动态管理内存；//离散内存。底层结构是双链表，支持在任意位置插入、删除和移动元素。
5. **forward_list**：单向链表
6. **queue**: 容器适配器，先进先出型容器（FIFO）；//C++设计模式之适配器模式。默认情况下，queue 使用 deque 作为底层容器。
7. **priority_queue**：容器适配器，严格弱序（Strict Weak Ordering），优先级队列；priority_queue 的核心特点在于严格弱序特性（strict weak ordering）：即保证容器中的第一个元素始终是所有元素中最大的。priority_queue 默认在 vector 上使用堆算法将 vector 中元素构造成大顶堆的结构，因此 priority_queue 就是堆
8. **stack**：容器适配器，后进先出型容器(LIFO)。任何时候外界只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。默认情况下，stack 使用 deque 作为底层容器。
9. 

## C++的内存管理方法

### 13. 类的对象存储空间

- 非静态成员的数据类型大小之和
- 编辑器加入的额外成员变量（如指向虚函数表的指针）
- 为了边缘对齐优化加入的padding
- 空类的对象的size是1

### 14. 简要说明C++的内存分区(腾讯:1)

<img src="/images/面经题目/image-20240314144006871.png" alt="image-20240314144006871" style="zoom:67%;" />

**栈**：在执行函数时，**函数内局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

**堆**：就是那些由 `new`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收

**全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0

**常量存储区：**这是一块比较特殊的存储区，这里面存放的是常量，不允许修改

**代码区：**存放函数体的二进制代码

### 15. 什么是内存池，如何实现

内存池（Memory Pool） 是一种**内存分配**方式。在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。

### 16. C++中类的数据成员和成员函数内存分布情况

数据成员在对象实例化后会占用一定内存空间。成员函数放在代码区

### 17. 关于this指针知道什么

- this指针是类的指针，指向对象的首地址
- this指针只能在成员函数中使用，在静态函数和全局函数中都不能使用
- this指针只有在成员函数中才有定义



# 计算机网络

### 1. 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

**三次握手：**客户端请求建立连接。服务器端确认请求，回复ACK，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。Server端接到FIN报文后，发出确认报文，

**四次挥手：**四次挥手在客户端发起中断连接请求的时候，服务器有可能还有数据没有发送完。1. Client端发起中断连接请求，也就是发送FIN报文。2. 服务器收到连接释放报文，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。3. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文。此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。4. 客户端收到服务器的连接释放报文后，必须发出确认，进入TIME-WAIT状态此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，才释放TCP，进入CLOSE状态。服务器只要收到了客户端发送的确认，直接进入CLOSE状态。

### 2. 为什么不用两次握手

主要为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。

### 3. 从输入 URL 到展现页面的全过程(腾讯:1)

- 浏览器解析URL输入
- 浏览器查找域名的IP地址(客户端发送DNS请求，DNS解析)
- 建立tcp连接
- 发送 HTTP / HTTPS 请求（建立 TLS 连接）
- 服务器响应请求
- 浏览器解析渲染界面
- HTTP 请求结束，断开 TCP 连接

### 4. OSI七层和TCP/IP四层模型的区别(腾讯:1)

#### OSI(open system interaction)七层模型：

- 应用层：协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP
- 表示层：数据的表示、安全、压缩。格式有，JPEG、ASCll、DECOIC、加密格式等
- 会话层：建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话
- 传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
- 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP
- 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
- 物理层：建立、维护、断开物理连接。

![image-20240312235338063](./images/面经题目/image-20240312235338063.png)

#### TCP/IP四层模型



### 5. session和cookie的区别

![image-20240312235428564](./images/面经题目/image-20240312235428564.png)



### 6. http和https的区别(腾讯:1)

安全超文本传输协议（HTTPS）是 HTTP 的一种更安全的版本或扩展。在 HTTPS 中，浏览器与服务器会在传输数据之前建立安全的加密连接。

HTTPS 将 HTTP 请求和响应与 SSL 和 TLS 技术相结合。

### 7. tcp/udp的区别，TCP为什么是可靠传输，TCP拥塞控制是怎样的(腾讯:1)

**udp**：传送数据前不需要先建立连接，远地主机在收到 UDP 报文后，也不需要给出任何确认。UDP不保证可靠的交付。适用于IM、语音、视频、直播等.

**tcp**：提供面向连接的服务。传送数据之前，必须先建立连接，数据传输结束之后，还要释放连接。一般用于文件发送传输、接收邮件、远程登录等要求可靠的场景。

TCP的可靠传输通过三次握手来建立连接，而且在数据通信过程中，有确认、窗口、重传、拥塞控制等机制，实现的。

#### TCP拥塞控制

TCP使用窗口实现**流量控制**。控制发送方的发送速度从而使接受者来得及接收并处理。

原理是：在通信过程中，接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，即TCP报文段首部中的“窗口”字段**rwnd**,来限制发送方向网络注入报文的速率。

TCP使用窗口实现**拥塞控制**。防止过多的包被发送到网络中，避免出现网络负载过大，网络拥塞的情况。

原理是：发送方根据其对当前网络拥塞程序的估计确定一个拥塞窗口**cwnd**。

最终A发送的窗口的实际大小是min(rwnd,cwnd)值。

==**慢开始算法**==

在TCP刚连接好，开始发送TCP报文段时，先令拥塞窗口cwnd=1，在每收到一个对新的报文段确认后，再将cwnd加1，慢开始算法，每经过一个传输轮次（即往返RTT)，拥塞窗口cwnd就会加倍，即呈指数形式增加，当慢开始算法把拥塞窗口cwnd增大到一个阈值ssthresh，改用拥塞避免算法。

==**拥塞避免算法**==

拥塞避免算法的做法是：发送端的拥塞窗口cwnd每经过一个往返RTT，按线性规律缓慢增长。

==**网络拥塞**==

当网络出现拥塞，不管是在慢开始阶段还是拥塞避免阶段，只要发送方检测到超时事件发送，就要把慢开始阈值ssthresh设置为出现拥塞时的发送方cwnd的一半（但不能小于2），然后将拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发送拥塞的路由器有足够的时间把队列中积压的分组处理完毕。

<img src="/images/面经题目/image-20240314154437720.png" alt="image-20240314154437720" style="zoom:67%;" />

**==快重传==**

当发送方连续收到三个重复的ACK报文，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。

**==快恢复==**

当发送端收到连续三个冗余ACK时，就执行“乘法减少”算法，把慢开始阈值ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始将拥塞窗口cwnd设置为1的不同之处，它把cwnd的值设置为慢开始阈值ssthresh减半后的数值，然后执行拥塞避免算法，使拥塞窗口缓慢线性增大

<img src="/images/面经题目/image-20240314155511687.png" alt="image-20240314155511687" style="zoom:67%;" />

### 8. IP地址子网掩码是什么(腾讯:1)

网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。翻译一下就是：一是用于屏蔽IP地址的一部分以区别**网络标识**和**主机**标识，并说明该IP地址是在**局域网**上，还是在远程网上。二是用于将一个大的IP网络划分为若干小的子网络。

# 操作系统

### 1. 线程的生命周期（进程的五个状态）

线程的生命周期通常包括以下几个阶段：

1. **创建（Creation）：** 在这个阶段，线程被创建并初始化。在许多编程语言中，你需要调用特定的函数或构造一个线程对象来创建线程。线程被创建后，它处于就绪状态，等待被调度执行。
2. **就绪（Ready）：** 一旦线程被创建，它进入就绪状态，表示它准备好被执行，但操作系统还没有选择执行它。在多线程环境中，可能有多个线程处于就绪状态，等待操作系统的调度。
3. **运行（Running）：**当线程被操作系统调度执行时，它进入运行状态。在运行状态下，线程执行其分配的任务或代码。线程可以主动放弃 CPU 控制权，或者在某些条件下被操作系统中断，进入等待状态或就绪状态。
4. **等待/阻塞（Waiting/Blocking）：** 线程可能会进入等待或阻塞状态，这通常发生在它需要等待某些条件满足或执行某些 I/O 操作时。在等待状态下，线程不会占用 CPU 时间，并且不会被调度执行。
5. **终止（Termination）：** 当线程完成了其任务或被显式终止时，它进入终止状态。在这个阶段，线程释放其资源，包括内存和文件句柄，并从系统中删除。终止后的线程通常不能再次执行。

### 2. 进程和线程的区别(腾讯:1)

进程是操作系统进行资源分配的最小单元，进程是一个实体，有自己的地址空间，每一个进程都会有一个独一无二的编号，被称为进程标识码。

线程是操作系统进行运算调度的最小单元。线程是进程中的 执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，但可以访问隶属于进程的资源，共享进程的地址空间

线程是指进程内的一个执行单元,也是进程内的可调度实体。一个程序至少有一个进程,一个进程至少有一个线程，一个线程只属于一个进程.

### 3. 进程间的通讯方式(腾讯:1)

https://blog.csdn.net/dl962454/article/details/117374916

1. 管道（pipe）：管道可用于具有亲缘关系的父子进程间的通信

2. 消息队列：消息队列在发送数据的时候，按照一个个独立单元(消息体)进行发送，其中每个消息体规定大小块，同时发送方和接收方约定好消息类型或者正文的格式。分位直接通信和间接通信

3. 共享内存

4. 信号量

5. 信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的

   **==可能用过的有==**
   
   管道：使用 | ，将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入

### 4. **并发和并行的区别**

并发和并行最开始都是操作系统中的概念，表示的是CPU执行多个任务的方式。

并发是指一个处理器同时处理多个任务，并行是指搓个处理器或者多核的处理器同时处理多个不同的任务。

并发是交替执行，并行是同时执行

![image-20240313000442961](./images/面经题目/image-20240313000442961.png)



### 5. 死锁的条件(腾讯:1)

- 互斥
- 不可抢占
- 请求与保持
- 循环等待

### 6. 死锁如何解决(腾讯:1)

超时释放

按照计划好的顺序获取锁

### 7. 为什么要加锁，锁有几种类型？(腾讯:1)

在多线程情况下共享操作同一个变量时，会导致数据不一致，出现并发安全问题，所以通过锁机制来保证数据的准确和唯一。

互斥锁(排队的线程会被挂起)、自旋锁(排队的进程不会挂起，一直占用CPU资源)、递归锁(同一个线程可以多次获得该资源锁，别的线程必须等待该线程释放所有次数的锁才能获得)、读写锁(允许多个线程读但只允许一个线程写)

### 8. 操作系统的几种文件管理系统(腾讯:1)



# 数据结构

### 1. 排序算法和思路(腾讯:1)

<img src="/images/面经题目/image-20240314185844274.png" alt="image-20240314185844274" style="zoom:67%;" />

#### 冒泡排序

**两两比较相邻记录的关键字**，如果是反序则交换，直到没有反序为止。如果是从小到大排序，会把最大的值排到后面。

#### 插入排序

直接插入排序：将一个记录插入到已经排好序的有序表中，从而得到一个新的有序表。

#### 选择排序

主要思路就是我们每一趟在 n-i+1 个记录中选取关键字最小的记录作为有序序列的第 i 个记录

#### 希尔排序

其思想简单点说就是有跨度的插入排序，这个跨度会逐渐变小(折半减少)，直到变为 1，变为 1 时记录也就基本有序，这时用到的也就是我们之前讲的直接插入排序了。

#### 堆排序

先把数组构造成一个大顶堆(所有父节点的值都要大于或等于子节点的值)，然后把堆顶元素和最后一个值交换。





### 2. 查找算法和思路(腾讯:1)

顺序查找

二分查找

二叉搜索树

### 3. 链表和数组的区别，栈和队列的区别(腾讯:1)



### 4. 树有几种遍历形式，二叉树用在什么场景(腾讯:1)



查询，二叉排序树，计算表达式

# 数据库

### 1. 有几种类型的数据库(腾讯:1)

### 2. 索引有哪些怎么实现的(腾讯:1)

### 3. 数据库事务类型有哪些(腾讯:1)

