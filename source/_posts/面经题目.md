---
title: 面经题目
date: 2024-03-12 17:03:05
tags:

categories:
    - 找工作
typora-root-url: ..
---

# **C++**

### 1.  C++中智能指针和指针的区别是什么(腾讯:1)

智能指针会自动管理内存，可以自动释放。普通的指针需要手动管理内存，释放。智能指针实际上是对普通指针加了一层封装机制，智能指针就是一个类。

在C++11中出现三种智能指针，分别是unique_ptr、shared_ptr、weak_ptr。这三种智能指针分别有各自的应用场景，**同时这些应用场景是有相互联系的**。https://blog.csdn.net/zsiming/article/details/125783890

-  unique_ptr的出现，在一定程度上解决了裸指针使用完没有及时释放导致的内存泄漏问题，但多个unique_ptr不能指向同一资源
-  shared_ptr的出现，解决了unique_ptr不能指向同一资源的问题。它的特点是引用计数不为0，就坚决不释放资源。这又导致了另一个问题：交叉引用导致资源无法释放，又会内存泄漏
- weak_ptr的特点是引用对象时引用计数不增加，但自能成为资源的观察者，无法使用资源。如果要使用资源，必须升级为shared_ptr。weak_ptr解决了shared_ptr交叉引用的问题。

### 2.   述 C++ 中智能指针的特点，简述 new 与 malloc 的区别

智能指针可以自动管理资源，包括share,unique和weak。在函数结束的时候会自动释放内存

new是C++中的操作符，malloc是函数。

new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数。

new相当于有两个步骤：分配内存(和malloc一样)；触发构造函数。

malloc在使用的时候需要显式填入申请内存的大小

new的返回值是对象类型的指针。而malloc返回的是void*,需要再一步进行强制类型转化。

### 3. 简述C++右值引用与转移语义

左值表达式表示的是对象的身份，右值表达式表达的是对象的值。

左值对应变量的存储位置，右值对应变量的值本身

有地址的变量就是左值，没有底质的字面值、临时值就是右值

![image-20240312171608374](./images/面经题目/image-20240312171608374.png)

引用就是给变量取一个别名，和原来的变量公用一块空间。一个变量可以有多个引用，改变引用的值就改变了变量的值

左值引用要求右边的值必须能够取出地址

左值的声明符号为”&”， 为了和左值区分，右值的声明符号为”&&”。

转移语句可以将资源(堆，系统对象等)从一个对象转移到另一个对象

右值引用实现了转移语义和精确传递，能够消除两个对象相互交互时不必要的对象拷贝，节省运算存储资源，提高运行效率。

![image-20240312171639634](./images/面经题目/image-20240312171639634.png)



### 4. 只定义析构函数，会自动生成哪些构造函数

与构造函数相反，析构函数是在对象被撤销的时自动调用。

默认生成的析构函数只能释放类的普通数据成员所占用的空间, 无法释放通过 new 或 malloc 进行申请的空间。

只定义析构函数，会生成默认构造函数和拷贝构造函数。

默认构造函数是给对象赋予初始值的函数

拷贝构造函数有编辑器调用来完成一些基于同一类的其他对象的构建及初始化

![image-20240312172005215](./images/面经题目/image-20240312172005215.png)

![image-20240312232954820](./images/面经题目/image-20240312232954820.png)

### 5. C++中多态是如何实现的

通过虚函数实现动态多态，通过函数重载(参数和返回值不一样)实现静态多态

多态：一个接口有多个形态

### 6.C++中虚函数表和虚函数表指针的创建时机

虚函数在继承的过程中可以重写基类的虚函数。

在运行时才知道子类调用的哪一个函数

虚函数表的创建时机：在编译器编译的时候生成，virtual关键字修饰的函数

虚函数表是虚函数地址的数组，每有一个虚函数，数组长度就＋1.在可执行程序中存放在只读数据段，在内存中存放在代码区。

虚函数表指针(在堆区)指向虚函数表的地址，虚函数地址又指向代码段中的函数的位置。

每个类对应一个虚函数表。类不同对象的虚函数表指针指向该类的虚函数表，但每个对象的虚函数表指针不同。

### 7. 虚拟内存的构成

内核空间

栈区

文件映射区

堆取

数据区(已初始化和未初始化的数据，静态存储区)

代码区

### 8. 构造函数的底层原理

先创建一个新对象，然后构造函数里的this替换成刚刚new的对象，通过强制转换的方式对新对象添加属性和方法

### 9. 引用和指针的区别(腾讯:1)

**指针**是一个变量，它保存了另一个变量的内存地址；**引用**是另一个变量的别名，与原变量共享内存地址。

 指针可以被重新赋值，指向不同的变量；引用在初始化后不能更改，始终指向同一个变量。

 指针可以为nullptr，表示不指向任何变量；引用必须绑定到一个变量，不能为nullptr。

### 10. qt里面有用到多线程吗

为什么在QT中要使用线程？

如果我们在写GUI程序的时候，如果某处的数据，计算比较复杂，当前主线程就会卡在这里，在具体表现就是界面会卡住。所以在这个时候多线程就起到了关键的作用， 我们将复杂的逻辑运算交给线程，由线程在后台处理。<u>（注意：线程不能操作图形界面，他的线程任务是在后台进行数据运算等）</u>

![image-20240313171845511](./images/面经题目/image-20240313171845511.png)

### 11. 面向对象的特点，三大特征(腾讯:1)

继承、多态、封装

其中，**封装**可以隐藏实现细节，使得代码模块化。

**继承**可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。

而**多态**则是为了实现另一个目的——接口重用！

<img src="/images/面经题目/image-20240314110741745.png" alt="image-20240314110741745" style="zoom:67%;" />

### 12. 常用的容器有哪些，底层原理是怎么样的(腾讯:1)

1. **array** :  **顺序容器**（支持随机访问），连续内存空间，固定大小；
2. **vector**：顺序容器（支持随机访问），动态调整大小，使用内存分配器动态管理内存；是能够动态调整大小的 array
3. **deque**：顺序容器（支持随机访问），动态调整大小，使用内存分配器动态管理内存；是一个可以在首尾两端进行动态增删的顺序容器。也是动态array
4. **list**：顺序容器（可顺序访问，但不支持随机访问），双链表，使用内存分配器动态管理内存；//离散内存。底层结构是双链表，支持在任意位置插入、删除和移动元素。
5. **forward_list**：单向链表
6. **queue**: 容器适配器，先进先出型容器（FIFO）；//C++设计模式之适配器模式。默认情况下，queue 使用 deque 作为底层容器。
7. **priority_queue**：容器适配器，严格弱序（Strict Weak Ordering），优先级队列；priority_queue 的核心特点在于严格弱序特性（strict weak ordering）：即保证容器中的第一个元素始终是所有元素中最大的。priority_queue 默认在 vector 上使用堆算法将 vector 中元素构造成大顶堆的结构，因此 priority_queue 就是堆
8. **stack**：容器适配器，后进先出型容器(LIFO)。任何时候外界只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。默认情况下，stack 使用 deque 作为底层容器。
9. 

## C++的内存管理方法

### 13. 类的对象存储空间

- 非静态成员的数据类型大小之和
- 编辑器加入的额外成员变量（如指向虚函数表的指针）
- 为了边缘对齐优化加入的padding
- 空类的对象的size是1

### 14. 简要说明C++的内存分区(腾讯:1)

<img src="/images/面经题目/image-20240314144006871.png" alt="image-20240314144006871" style="zoom:67%;" />

**栈**：在执行函数时，**函数内局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

**堆**：就是那些由 `new`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收

**全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0

**常量存储区：**这是一块比较特殊的存储区，这里面存放的是常量，不允许修改

**代码区：**存放函数体的二进制代码

### 15. 什么是内存池，如何实现

内存池（Memory Pool） 是一种**内存分配**方式。在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。

### 16. C++中类的数据成员和成员函数内存分布情况

数据成员在对象实例化后会占用一定内存空间。成员函数放在代码区

### 17. 关于this指针知道什么

- this指针是类的指针，指向对象的首地址
- this指针只能在成员函数中使用，在静态函数和全局函数中都不能使用
- this指针只有在成员函数中才有定义

### 18. C++11的新特性

介绍几种常用的新特性

1. **nullptr**。用来区分空指针和0，nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。当需要使用 NULL 时候，直接使用 nullptr。

2. **类型推导**。C++11引入了auto和decltype这两个关键字实现了类型推导。

   auto可以对变量的类型进行推导，最常见的是迭代器。auto不能用于函数传参，也不能用于推导数组类型。

   decltype的推导对象总是以一个普通表达式作为参数，返回该表达式的类型，而且decltype并不会对表达式进行求值。

3. 区间迭代。for(auto i:arr)

4. 初始化列表

### 19. 简述 vector 的实现原理

vector是一个动态数组，用于维护一段连续的动态控件，内部有三个成员函数，用来储存起始位置，已使用位置，以及整个空间的最后位置，每当动态内存用完时，它会按照原内存的2倍，重新申请新内存。将原内存的数据拷贝到新内存，释放掉原内存。

### 20. 简述hashmap的底层实现原理

使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素。

hash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：

- 得到key
- 通过hash函数得到hash值
- 得到桶号(一般都为hash值对桶数求模)
- 存放key和value在桶内。

其取值过程是:

- 得到key
- 通过hash函数得到hash值
- 得到桶号(一般都为hash值对桶数求模)
- 比较桶的内部元素是否与key相等，若都不相等，则没有找到。
- 取出相等的记录的value。
- hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).

hashmap是数组和链表组成的，数据结构中又叫“链表散列”。单线链表如果长度超过8的话会变成红黑树。

单线链表只是为了解决hash冲突准备的，将哈希表的每个位置都设置为一个链表头节点，发生哈希冲突时，将新的键值对插入到对应的链表中。

### 21. include <>和“”区别

一、引用的头文件不同
#include< >引用的是编译器的类库路径里面的头文件。
#include“ ”引用的是你程序目录的相对路径中的头文件。
二、用法不同
#include< >用来包含标准头文件(例如stdio.h或stdlib.h).
#include“ ”用来包含非标准头文件。
三、调用文件的顺序不同
#include< >编译程序会先到标准函数库中调用文件。
#include“ ”编译程序会先从当前目录中调用文件。
四、预处理程序的指示不同
#include< >指示预处理程序到预定义的缺省路径下寻找文件。
#include“ ”指示预处理程序先到当前目录下寻找文件，再到预定义的缺省路径下寻找文件。

### 22. 面向对象优点

可重用性好，我们可以利用其继承、封装、多态的特性来对一个类或者类中的函数实现进行重复利用

可维护性好

易于理解

能更好的对问题进行建模分析，在具体实现时，我们可以跟踪一个对象不同属性的状态

### 23. C++从编译到运行发生了什么

C/C++程序编译流程：预处理->编译->汇编->链接

![image-20240407104820367](/images/面经题目/image-20240407104820367.png)

### 24. C++中const和static的区别

Const

<img src="/images/面经题目/image-20240408111019744.png" alt="image-20240408111019744" style="zoom:67%;" />

Static有四种用途：

<img src="/images/面经题目/image-20240408110759006.png" alt="image-20240408110759006" style="zoom:67%;" />







# 计算机网络

### 1. 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

**三次握手：**客户端请求建立连接。服务器端确认请求，回复ACK，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。

![image-20240327182628099](/images/面经题目/image-20240327182628099.png)

**四次挥手：**四次挥手在客户端发起中断连接请求的时候，服务器有可能还有数据没有发送完。1. Client端发起中断连接请求，也就是发送FIN报文。2. 服务器收到连接释放报文，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。3. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文。此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。4. 客户端收到服务器的连接释放报文后，必须发出确认，进入TIME-WAIT状态此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，才释放TCP，进入CLOSE状态。服务器只要收到了客户端发送的确认，直接进入CLOSE状态。

![image-20240327182720192](/images/面经题目/image-20240327182720192.png)

### 2. 为什么不用两次握手

主要为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。

### 3. 从输入 URL 到展现页面的全过程(腾讯:1)

- 浏览器解析URL输入
- 浏览器查找域名的IP地址(客户端发送DNS请求，DNS解析)
- 建立tcp连接
- 发送 HTTP / HTTPS 请求（建立 TLS 连接）
- 服务器响应请求
- 浏览器解析渲染界面
- HTTP 请求结束，断开 TCP 连接

### 4. OSI七层和TCP/IP四层模型的区别(腾讯:1)

#### OSI(open system interaction)七层模型：

- 应用层：协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP
- 表示层：数据的表示、安全、压缩。格式有，JPEG、ASCll、DECOIC、加密格式等
- 会话层：建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话
- 传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
- 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP
- 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
- 物理层：建立、维护、断开物理连接。

![image-20240312235338063](./images/面经题目/image-20240312235338063.png)

#### TCP/IP四层模型



### 5. session和cookie的区别

![image-20240312235428564](./images/面经题目/image-20240312235428564.png)



### 6. http和https的区别(腾讯:1)

安全超文本传输协议（HTTPS）是 HTTP 的一种更安全的版本或扩展。在 HTTPS 中，浏览器与服务器会在传输数据之前建立安全的加密连接。

HTTPS 将 HTTP 请求和响应与 SSL 和 TLS 技术相结合。

### 7. tcp/udp的区别，TCP为什么是可靠传输，TCP拥塞控制是怎样的(腾讯:1)

**udp**：传送数据前不需要先建立连接，远地主机在收到 UDP 报文后，也不需要给出任何确认。UDP不保证可靠的交付。适用于IM、语音、视频、直播等.

**tcp**：提供面向连接的服务。传送数据之前，必须先建立连接，数据传输结束之后，还要释放连接。一般用于文件发送传输、接收邮件、远程登录等要求可靠的场景。

TCP的可靠传输通过三次握手来建立连接，而且在数据通信过程中，有确认、窗口、重传、拥塞控制等机制，实现的。

#### TCP拥塞控制

TCP使用窗口实现**流量控制**。控制发送方的发送速度从而使接受者来得及接收并处理。

原理是：在通信过程中，接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，即TCP报文段首部中的“窗口”字段**rwnd**,来限制发送方向网络注入报文的速率。

TCP使用窗口实现**拥塞控制**。防止过多的包被发送到网络中，避免出现网络负载过大，网络拥塞的情况。

原理是：发送方根据其对当前网络拥塞程序的估计确定一个拥塞窗口**cwnd**。

最终A发送的窗口的实际大小是min(rwnd,cwnd)值。

拥塞窗口(cwnd)反映网络的拥塞程度。发送窗口(rwnd)反映接收方拥塞程度

==**慢开始算法**==

在TCP刚连接好，开始发送TCP报文段时，先令拥塞窗口cwnd=1，在每收到一个对新的报文段确认后，再将cwnd加1，慢开始算法，每经过一个传输轮次（即往返RTT)，拥塞窗口cwnd就会加倍，即呈指数形式增加，当慢开始算法把拥塞窗口cwnd增大到一个阈值ssthresh，改用拥塞避免算法。

==**拥塞避免算法**==

拥塞避免算法的做法是：发送端的拥塞窗口cwnd每经过一个往返RTT，按线性规律缓慢增长。

==**网络拥塞**==

当网络出现拥塞，不管是在慢开始阶段还是拥塞避免阶段，只要发送方检测到超时事件发送，就要把慢开始阈值ssthresh设置为出现拥塞时的发送方cwnd的一半（但不能小于2），然后将拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发送拥塞的路由器有足够的时间把队列中积压的分组处理完毕。

<img src="/images/面经题目/image-20240314154437720.png" alt="image-20240314154437720" style="zoom:67%;" />

**==快重传==**

当发送方连续收到三个重复的ACK报文，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。

**==快恢复==**

当发送端收到连续三个冗余ACK时，就执行“乘法减少”算法，把慢开始阈值ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始将拥塞窗口cwnd设置为1的不同之处，它把cwnd的值设置为慢开始阈值ssthresh减半后的数值，然后执行拥塞避免算法，使拥塞窗口缓慢线性增大

<img src="./images/面经题目/image-20240314155511687.png" alt="image-20240314155511687" style="zoom:67%;" />

### 8. IP地址子网掩码是什么(腾讯:1)

网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。翻译一下就是：一是用于屏蔽IP地址的一部分以区别**网络标识**和**主机**标识，并说明该IP地址是在**局域网**上，还是在远程网上。二是用于将一个大的IP网络划分为若干小的子网络。

### 9. https工作原理

HTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：

![image-20240407110941386](/images/面经题目/image-20240407110941386.png)

### 10.对称加密和非对称加密



### 11. TCP长短连接流程，怎么实现

==长连接==指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

Client方与Server方先建立通讯连接，连接建立后不断开， 然后再进行报文发送和接收。 

连接->传输数据->保持连接 -> 传输数据-> 。。。->关闭连接。 

例如在线游戏。

==短连接==指Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。

连接->传输数据->关闭连接  

HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 

### 12.  TCP协议如何保障可靠传输的

- **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- **数据校验**：TCP报文头有校验和，用于校验报文是否损坏。
- **数据合理分片和排序**：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。
- **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失
- **拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失

### 13. http1.0，http1.1和http2.0的区别

HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。

==HTTP 2.0 和 HTTP 1.X相比的新特性==

**新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

**多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。



### 14. 常见的HTTP状态码有哪些？

| 状态码 |               类别               |            含义            |
| :----: | :------------------------------: | :------------------------: |
|  1XX   |  Informational（信息性状态码）   |     接收的请求正在处理     |
|  2XX   |      Success（成功状态码）       |      请求正常处理完毕      |
|  3XX   |   Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |
|  4XX   | Client Error（客户端错误状态码） |     服务器无法处理请求     |
|  5XX   | Server Error（服务器错误状态码） |     服务器处理请求出错     |

1. 1XX 信息

   **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

2. 2XX 成功

   - **200 OK**
   - **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
   - **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

3. 3XX 重定向

   - **301 Moved Permanently** ：永久性重定向
   - **302 Found** ：临时性重定向
   - **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
   - **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
   - **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

4. 4XX 客户端错误

   - **400 Bad Request** ：请求报文中存在语法错误。
   - **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
   - **403 Forbidden** ：请求被拒绝。
   - **404 Not Found**

5. 5xx 服务器错误

   - **500 Internal Server Error** ：服务器正在执行请求时发生错误。
   - **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### 15. HTTP长连接和TCP长连接有什么区别

- HTTP 的 Keep-Alive，是由应用层（用户态）实现的，称为 HTTP 长连接；
- TCP 的 Keepalive，是由TCP 层（内核态）实现的，称为 TCP 保活机制；

# 操作系统

### 1. 线程的生命周期（进程的五个状态）

线程的生命周期通常包括以下几个阶段：

1. **创建（Creation）：** 在这个阶段，线程被创建并初始化。在许多编程语言中，你需要调用特定的函数或构造一个线程对象来创建线程。线程被创建后，它处于就绪状态，等待被调度执行。
2. **就绪（Ready）：** 一旦线程被创建，它进入就绪状态，表示它准备好被执行，但操作系统还没有选择执行它。在多线程环境中，可能有多个线程处于就绪状态，等待操作系统的调度。
3. **运行（Running）：**当线程被操作系统调度执行时，它进入运行状态。在运行状态下，线程执行其分配的任务或代码。线程可以主动放弃 CPU 控制权，或者在某些条件下被操作系统中断，进入等待状态或就绪状态。
4. **等待/阻塞（Waiting/Blocking）：** 线程可能会进入等待或阻塞状态，这通常发生在它需要等待某些条件满足或执行某些 I/O 操作时。在等待状态下，线程不会占用 CPU 时间，并且不会被调度执行。
5. **终止（Termination）：** 当线程完成了其任务或被显式终止时，它进入终止状态。在这个阶段，线程释放其资源，包括内存和文件句柄，并从系统中删除。终止后的线程通常不能再次执行。

### 2. 进程和线程的区别(腾讯:1)

进程是操作系统进行资源分配的最小单元，进程是一个实体，有自己的地址空间，每一个进程都会有一个独一无二的编号，被称为进程标识码。

线程是操作系统进行运算调度的最小单元。线程是进程中的 执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，但可以访问隶属于进程的资源，共享进程的地址空间

线程是指进程内的一个执行单元,也是进程内的可调度实体。一个程序至少有一个进程,一个进程至少有一个线程，一个线程只属于一个进程.

### 3. 进程间的通讯方式(腾讯:1)

https://blog.csdn.net/dl962454/article/details/117374916

1. 管道（pipe）：管道可用于具有亲缘关系的父子进程间的通信

2. 消息队列：消息队列在发送数据的时候，按照一个个独立单元(消息体)进行发送，其中每个消息体规定大小块，同时发送方和接收方约定好消息类型或者正文的格式。分位直接通信和间接通信

3. 共享内存

4. 信号量

5. 信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的

   **==可能用过的有==**
   
   管道：使用 | ，将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入

### 4. **并发和并行的区别**

并发和并行最开始都是操作系统中的概念，表示的是CPU执行多个任务的方式。

并发是指一个处理器同时处理多个任务，并行是指搓个处理器或者多核的处理器同时处理多个不同的任务。

并发是交替执行，并行是同时执行

![image-20240313000442961](./images/面经题目/image-20240313000442961.png)



### 5. 死锁的条件(腾讯:1)

- 互斥
- 不可抢占
- 请求与保持
- 循环等待

### 6. 死锁如何解决(腾讯:1)

超时释放

按照计划好的顺序获取锁

### 7. 为什么要加锁，锁有几种类型？(腾讯:1)

在多线程情况下共享操作同一个变量时，会导致数据不一致，出现并发安全问题，所以通过锁机制来保证数据的准确和唯一。

互斥锁(排队的线程会被挂起)、自旋锁(排队的进程不会挂起，一直占用CPU资源)、递归锁(同一个线程可以多次获得该资源锁，别的线程必须等待该线程释放所有次数的锁才能获得)、读写锁(允许多个线程读但只允许一个线程写)

### 8. 操作系统的几种文件管理系统(腾讯:1)

ext4,ext3,NTFS

### 9. 动态链接静态链接区别

一个C或者C++文件需要经过预处理、编译、汇编、链接四步才能形成一个可执行文件。

![image-20240401163056246](./images/面经题目/image-20240401163056246.png)

- **静态链接：** 在链接阶段，把所有需要的函数和数据编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
- 空间浪费：因为每个可执行程序中对所有需要的静态库文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
- 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
- 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
- **动态链接：** 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在**程序运行时**才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
  - 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；
  - 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
  - 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

### 10. 介绍一下I/O多路复用

这一篇讲的比较清楚https://zhuanlan.zhihu.com/p/63179839

一个进程虽然任意时刻只能处理一个请求，但是处理每个请求事件时，耗时控制在1ms以内，这样1秒内就可以处理上千个请求，相当于多个请求复用了一个进程，这就是多路复用。也叫做时分多路复用

select/poll/epoll内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。

==select/poll==

select仅仅知道有I/O事件发生，却并不知道是哪几个流（可能有一个，多个，甚至全部）。我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。

select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的。

poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制。

**缺点**：每次调用 select/poll时 ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大。对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）。

==epoll==





### 11.线程调度

先到先服务：

短作业优先：长作业有可能饿死

优先级队列：

最短剩余时间优先：

时间片轮转：

### 12. 介绍一下虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。

这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。

### 13. 线程阻塞

等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态

同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)

其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态

### 14. 线程join()操作

某个线程可以通过调用join操作来等待另外一个线程的执行，直到另外一个线程执行完毕。





# 数据结构与算法

### 1. 排序算法和思路(腾讯:1)

<img src="/images/面经题目/image-20240314185844274.png" alt="image-20240314185844274" style="zoom:67%;" />

#### 冒泡排序

**两两比较相邻记录的关键字**，如果是反序则交换，直到没有反序为止。如果是从小到大排序，会把最大的值排到后面。

#### 插入排序

直接插入排序：将一个记录插入到已经排好序的有序表中，从而得到一个新的有序表。

#### 选择排序

主要思路就是我们每一趟在 n-i+1 个记录中选取关键字最小的记录作为有序序列的第 i 个记录

#### 希尔排序

其思想简单点说就是有跨度的插入排序，这个跨度会逐渐变小(折半减少)，直到变为 1，变为 1 时记录也就基本有序，这时用到的也就是我们之前讲的直接插入排序了。

#### 堆排序

堆需要是一个完全二叉树。

先把数组构造成一个大顶堆(所有父节点的值都要大于或等于子节点的值)，然后把堆顶元素和最后一个值交换。

从第h-1层开始，每个节点做一个heapify(该节点和左右孩子，选择最大的值作为根节点) 

https://www.bilibili.com/video/BV1Eb41147dK?from=search&seid=3993837508839965022

#### 快速排序



#### 归并排序





### 2. 查找算法和思路(腾讯:1)

顺序查找

二分查找

二叉搜索树

### 3. 链表和数组的区别，栈和队列的区别，栈和堆的区别(腾讯:1)

操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作（当然 C++ 的 new 不仅仅是申请内存这么简单）。内存中的空闲空间并不是连续的，而是不同程序占用了不同的一块一块的内存，即使是同一个程序也可能占用了不同地方的多块内存。操作系统中则会对这些空间进行统一的管理，在应用程序提出申请时，就会从堆中按照一定算法找出一块可用内存，标记占用空间等信息之后返回其起始地址给程序。

### 4. 树有几种遍历形式，二叉树用在什么场景(腾讯:1)

前序遍历，中序遍历，后序遍历

查询，二叉排序树，计算表达式

### 5. 求图中最短路径的算法

**Dijkstra(迪杰斯特拉)算法**

**Floyd-Warshall算法**

### 6. B树和B+树

==B树==

B树是一种平衡的多路查找树，允许一个节点存放多个数据。

树中每个节点至多有m个孩子节点。

每个节点的结构如下所示。P是指向孩子节点的指针，k是关键字。n代表关键字的个数

![image-20240407154420415](/images/面经题目/image-20240407154420415.png)

![image-20240402214328942](./images/面经题目/image-20240402214328942.png)

为了描述B-树，首先定义一条记录为一个键值对[key,data]，key和data分布在整棵树的结构当中

![image-20240402214806914](./images/面经题目/image-20240402214806914.png)

每个节点一般放置一页的数据，每个节点的大小是16K。data的大小比较大，会限制每个节点存储的键值数目，所以树的深度会变大。

B+树的数据不存储在非叶子结点。非叶子结点只存储记录和指针，叶子结点存储数据 

### 7. 红黑树

是一种自平衡的二叉搜索树。

红黑树的原则有以下几点：

- 特性1：节点非黑即红
- 特性2：根节点一定是黑色
- 特性3：叶子节点（NIL）一定是黑色
- 特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 特性5：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。

### 8. 二分查找



# 数据库

### 1. 有几种类型的数据库(腾讯:1)

### 2. 索引有哪些怎么实现的(腾讯:1)

### 3. 数据库事务类型有哪些(腾讯:1)

### 4. LSM-tree介绍，什么是追加写

LSM-tree(Log Structured-Merge Tree) 是一种分层，有序，面向磁盘的数据结构，其核心思想是充分了利用了，磁盘批量的顺序写要远比随机写性能高出很多。这种结构的写入，全部都是以Append的模式追加，不存在删除和修改。

![image-20240405213820270](/images/面经题目/image-20240405213820270.png)

LSM树有以下三个重要组成部分：

==MemTable==

MemTable是在***内存\***中的数据结构，用于保存最近更新的数据，会按照Key有序地组织这些数据。

==Immutable MemTable==

当 MemTable达到一定大小后，会转化成Immutable MemTable。Immutable MemTable是将转MemTable变为SSTable的一种中间状态。写操作由新的MemTable处理，在转存过程中不阻塞数据更新操作。

==SSTable(Sorted String Table)==

***有序键值对***集合，是LSM树组在磁盘中的数据结构。为了加快SSTable的读取，可以通过建立key的索引以及布隆过滤器来加快key的查找。

LSM树(Log-Structured-Merge-Tree)正如它的名字一样，LSM树会将所有的数据插入、修改、删除等操作记录(注意是操作记录)保存在内存之中，当此类操作达到一定的数据量后，再批量地顺序写入到磁盘当中。当MemTable达到一定大小flush到持久化存储变成SSTable后，在不同的SSTable中，可能存在相同Key的记录，当然最新的那条记录才是准确的。

# Linux

